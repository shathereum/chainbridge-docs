{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83c\udf09 Overview \u00b6 Summary \u00b6 At a high level, ChainBridge is a message passing protocol. Events on a source chain are used to create a message that is then delivered to the destination chain. We define the concept of a Listener to extract events from a chain and construct a message, and a Writer to interpret messages and submit transactions to a chain. Relevant repos \u00b6 ChainBridge \u00b6 This is the core bridging software that Relayers run between chains. chainbridge-solidity \u00b6 The Solidity contracts required for chainbridge. Includes deployment and interaction CLI. chainbridge-substrate \u00b6 A substrate pallet that can be integrated into a chain, as well as an example pallet to demonstrate chain integration. chainbridge-utils \u00b6 A collection of packages used by the core bridging software. chainbridge-deploy \u00b6 Some tooling to help with deployments.","title":"Overview"},{"location":"#overview","text":"","title":"\ud83c\udf09  Overview "},{"location":"#summary","text":"At a high level, ChainBridge is a message passing protocol. Events on a source chain are used to create a message that is then delivered to the destination chain. We define the concept of a Listener to extract events from a chain and construct a message, and a Writer to interpret messages and submit transactions to a chain.","title":"Summary"},{"location":"#relevant-repos","text":"","title":"Relevant repos"},{"location":"#chainbridge","text":"This is the core bridging software that Relayers run between chains.","title":"ChainBridge"},{"location":"#chainbridge-solidity","text":"The Solidity contracts required for chainbridge. Includes deployment and interaction CLI.","title":"chainbridge-solidity"},{"location":"#chainbridge-substrate","text":"A substrate pallet that can be integrated into a chain, as well as an example pallet to demonstrate chain integration.","title":"chainbridge-substrate"},{"location":"#chainbridge-utils","text":"A collection of packages used by the core bridging software.","title":"chainbridge-utils"},{"location":"#chainbridge-deploy","text":"Some tooling to help with deployments.","title":"chainbridge-deploy"},{"location":"cli-options/","text":"CLI Options \u00b6 Flags \u00b6 Global \u00b6 -- config value JSON configuration file -- verbosity value Supports levels crit ( silent ) to trce ( trace ) ( default : \"info\" ) -- keystore value Path to keystore directory ( default : \"./keys\" ) -- blockstore value Specify path for blockstore -- fresh Disables loading from blockstore at start . Opts will still be used if specified . ( default : false ) -- latest Overrides blockstore and start block , starts from latest block ( default : false ) -- metrics Enables metric server ( default : false ) -- metricsPort value Port to serve metrics on ( default : 8001 ) -- testkey value Applies a predetermined test keystore to the chains . -- help , - h show help ( default : false ) -- version , - v print the version ( default : false ) Account Management \u00b6 The commands can be used to manage keys in the local keystore. You can view available keys with chainbridge accounts list . chainbridge accounts generate \u00b6 --password value Password used to encrypt the keystore. Used with --generate, --import, or --unlock --sr25519 Specify account/key type as sr25519. (default: false) --secp256k1 Specify account/key type as secp256k1. (default: false) --network value Specify the network to use for the address encoding (substrate/polkadot/centrifuge) (default: substrate) chainbridge accounts import \u00b6 --ethereum Import an existing ethereum keystore, such as from geth. (default: false) --privateKey value Import a hex representation of a private key into a keystore. --sr25519 Specify account/key type as sr25519. (default: false) --secp256k1 Specify account/key type as secp256k1. (default: false) --password value Password used to encrypt the keystore. Used with --generate, --import, or --unlock --network value Specify the network to use for the address encoding (substrate/polkadot/centrifuge) (default: substrate) Environment Variables \u00b6 KEYSTORE_PASSWORD : The password to use when loading the keystore. BLOCK_TIMEOUT : The duration (seconds) until a chain is considered \"unhealthy\"","title":"CLI Options"},{"location":"cli-options/#cli-options","text":"","title":"CLI Options"},{"location":"cli-options/#flags","text":"","title":"Flags"},{"location":"cli-options/#global","text":"-- config value JSON configuration file -- verbosity value Supports levels crit ( silent ) to trce ( trace ) ( default : \"info\" ) -- keystore value Path to keystore directory ( default : \"./keys\" ) -- blockstore value Specify path for blockstore -- fresh Disables loading from blockstore at start . Opts will still be used if specified . ( default : false ) -- latest Overrides blockstore and start block , starts from latest block ( default : false ) -- metrics Enables metric server ( default : false ) -- metricsPort value Port to serve metrics on ( default : 8001 ) -- testkey value Applies a predetermined test keystore to the chains . -- help , - h show help ( default : false ) -- version , - v print the version ( default : false )","title":"Global"},{"location":"cli-options/#account-management","text":"The commands can be used to manage keys in the local keystore. You can view available keys with chainbridge accounts list .","title":"Account Management"},{"location":"cli-options/#chainbridge-accounts-generate","text":"--password value Password used to encrypt the keystore. Used with --generate, --import, or --unlock --sr25519 Specify account/key type as sr25519. (default: false) --secp256k1 Specify account/key type as secp256k1. (default: false) --network value Specify the network to use for the address encoding (substrate/polkadot/centrifuge) (default: substrate)","title":"chainbridge accounts generate"},{"location":"cli-options/#chainbridge-accounts-import","text":"--ethereum Import an existing ethereum keystore, such as from geth. (default: false) --privateKey value Import a hex representation of a private key into a keystore. --sr25519 Specify account/key type as sr25519. (default: false) --secp256k1 Specify account/key type as secp256k1. (default: false) --password value Password used to encrypt the keystore. Used with --generate, --import, or --unlock --network value Specify the network to use for the address encoding (substrate/polkadot/centrifuge) (default: substrate)","title":"chainbridge accounts import"},{"location":"cli-options/#environment-variables","text":"KEYSTORE_PASSWORD : The password to use when loading the keystore. BLOCK_TIMEOUT : The duration (seconds) until a chain is considered \"unhealthy\"","title":"Environment Variables"},{"location":"configuration/","text":"Configuration \u00b6 Note: TOML configs have been deprecated in favour of JSON A chain configurations take this form: { \"name\": \"eth\", // Human-readable name \"type\": \"ethereum\", // Chain type (eg. \"ethereum\" or \"substrate\") \"id\": \"0\", // Chain ID \"endpoint\": \"ws://<host>:<port>\", // Node endpoint \"from\": \"0xff93...\", // On-chain address of relayer \"opts\": {}, // Chain-specific configuration options (see below) } See config.json.example for an example configuration. Ethereum Options \u00b6 Ethereum chains support the following additional options: { \"bridge\": \"0x12345...\", // Address of the bridge contract (required) \"erc20Handler\": \"0x1234...\", // Address of erc20 handler (required) \"erc721Handler\": \"0x1234...\", // Address of erc721 handler (required) \"genericHandler\": \"0x1234...\", // Address of generic handler (required) \"maxGasPrice\": \"0x1234\", // Gas price for transactions (default: 20000000000) \"gasLimit\": \"0x1234\", // Gas limit for transactions (default: 6721975) \"http\": \"true\", // Whether the chain connection is ws or http (default: false) \"startBlock\": \"1234\", // The block to start processing events from (default: 0) \"blockConfirmations\": \"10\" // Number of blocks to wait before processing a block } Substrate Options \u00b6 Substrate supports the following additonal options: { \"startBlock\": \"1234\" // The block to start processing events from (default: 0) \"useExtendedCall\": \"true\" // Extend extrinsic calls to substrate with ResourceID. Used for backward compatibility with example pallet. } Blockstore \u00b6 The blockstore is used to record the last block the relayer processed, so it can pick up where it left off. If a startBlock option is provided (see Configuration ), then the greater of startBlock and the latest block in the blockstore is used at startup. To disable loading from the blockstore specify the --fresh flag. A custom path for the blockstore can be provided with --blockstore <path> . For development, the --latest flag can be used to start from the current block and override any other configuration. Keystore \u00b6 ChainBridge requires keys to sign and submit transactions, and to identify each bridge node on chain. To use secure keys, see chainbridge accounts --help . The keystore password can be supplied with the KEYSTORE_PASSWORD environment variable. To import external ethereum keys, such as those generated with geth, use chainbridge accounts import --ethereum /path/to/key . To import private keys as keystores, use chainbridge account import --privateKey key . For testing purposes, chainbridge provides 5 test keys. The can be used with --testkey <name> , where name is one of Alice , Bob , Charlie , Dave , or Eve .","title":"Overview"},{"location":"configuration/#configuration","text":"Note: TOML configs have been deprecated in favour of JSON A chain configurations take this form: { \"name\": \"eth\", // Human-readable name \"type\": \"ethereum\", // Chain type (eg. \"ethereum\" or \"substrate\") \"id\": \"0\", // Chain ID \"endpoint\": \"ws://<host>:<port>\", // Node endpoint \"from\": \"0xff93...\", // On-chain address of relayer \"opts\": {}, // Chain-specific configuration options (see below) } See config.json.example for an example configuration.","title":"Configuration"},{"location":"configuration/#ethereum-options","text":"Ethereum chains support the following additional options: { \"bridge\": \"0x12345...\", // Address of the bridge contract (required) \"erc20Handler\": \"0x1234...\", // Address of erc20 handler (required) \"erc721Handler\": \"0x1234...\", // Address of erc721 handler (required) \"genericHandler\": \"0x1234...\", // Address of generic handler (required) \"maxGasPrice\": \"0x1234\", // Gas price for transactions (default: 20000000000) \"gasLimit\": \"0x1234\", // Gas limit for transactions (default: 6721975) \"http\": \"true\", // Whether the chain connection is ws or http (default: false) \"startBlock\": \"1234\", // The block to start processing events from (default: 0) \"blockConfirmations\": \"10\" // Number of blocks to wait before processing a block }","title":"Ethereum Options"},{"location":"configuration/#substrate-options","text":"Substrate supports the following additonal options: { \"startBlock\": \"1234\" // The block to start processing events from (default: 0) \"useExtendedCall\": \"true\" // Extend extrinsic calls to substrate with ResourceID. Used for backward compatibility with example pallet. }","title":"Substrate Options"},{"location":"configuration/#blockstore","text":"The blockstore is used to record the last block the relayer processed, so it can pick up where it left off. If a startBlock option is provided (see Configuration ), then the greater of startBlock and the latest block in the blockstore is used at startup. To disable loading from the blockstore specify the --fresh flag. A custom path for the blockstore can be provided with --blockstore <path> . For development, the --latest flag can be used to start from the current block and override any other configuration.","title":"Blockstore"},{"location":"configuration/#keystore","text":"ChainBridge requires keys to sign and submit transactions, and to identify each bridge node on chain. To use secure keys, see chainbridge accounts --help . The keystore password can be supplied with the KEYSTORE_PASSWORD environment variable. To import external ethereum keys, such as those generated with geth, use chainbridge accounts import --ethereum /path/to/key . To import private keys as keystores, use chainbridge account import --privateKey key . For testing purposes, chainbridge provides 5 test keys. The can be used with --testkey <name> , where name is one of Alice , Bob , Charlie , Dave , or Eve .","title":"Keystore"},{"location":"installation/","text":"Installation``` \u00b6 Dependencies \u00b6 Subkey : Used for substrate key management. Only required if connecting to a substrate chain. make install-subkey Building from Source \u00b6 To build chainbridge in ./build . make build or Use go install to add chainbridge to your GOBIN. make install Docker \u00b6 The official ChainBridge Docker image can be found here . To build the Docker image locally run: docker build -t chainsafe/chainbridge . To start ChainBridge: docker run -v ./config.json:/config.json chainsafe/chainbridge","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation```"},{"location":"installation/#dependencies","text":"Subkey : Used for substrate key management. Only required if connecting to a substrate chain. make install-subkey","title":"Dependencies"},{"location":"installation/#building-from-source","text":"To build chainbridge in ./build . make build or Use go install to add chainbridge to your GOBIN. make install","title":"Building from Source"},{"location":"installation/#docker","text":"The official ChainBridge Docker image can be found here . To build the Docker image locally run: docker build -t chainsafe/chainbridge . To start ChainBridge: docker run -v ./config.json:/config.json chainsafe/chainbridge","title":"Docker"},{"location":"local/","text":"Running Locally \u00b6 Prerequisites \u00b6 Docker, docker-compose chainbridge v1.0.0 binary (see README ) Polkadot JS Portal ( https://portal.chain.centrifuge.io ) Connect to your local node (below) by clicking in the top-left corner and using ws://localhost:9944 You will need to setup the type definitions for the chain by selecting Settings -> Developer Type definitions can be found here: PolkadotJS Apps cb-sol-cli (see README ) Starting Local Chains \u00b6 The easiest way to get started is to use the docker-compose file found here: https://gist.github.com/ansermino/f1571bb354d2007b26dce53d52dbca75 . This will start a geth instance and an instance of chainbridge-substrate-chain: docker-compose -f ./docker-compose-geth-substrate.yml up -V (Use -V to always start with new chains. These instructions depend on deterministic ethereum addresses, which are used as defaults implicitly by some of these commands. Avoid re-deploying the contracts without restarting both chains, or ensure to specify all the required parameters.) On-Chain Setup (Ethereum) \u00b6 Deploy Contracts \u00b6 To deploy the contracts on to the Ethereum chain, run the following: cb-sol-cli deploy --all --relayerThreshold 1 After running, the expected output looks like this: ================================================================ Url: http://localhost:8545 Deployer: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca Gas Limit: 8000000 Gas Price: 20000000 Deploy Cost: 0 .0 Options ======= Chain Id: 0 Threshold: 2 Relayers: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca,0x8e0a907331554AF72563Bd8D43051C2E64Be5d35,0x24962717f8fA5BA3b931bACaF9ac03924EB475a0,0x148FfB2074A9e59eD58142822b3eB3fcBffb0cd7,0x4CEEf6139f00F9F4535Ad19640Ff7A0137708485 Bridge Fee: 0 Expiry: 100 Contract Addresses ================================================================ Bridge: 0x62877dDCd49aD22f5eDfc6ac108e9a4b5D2bD88B ---------------------------------------------------------------- Erc20 Handler: 0x3167776db165D8eA0f51790CA2bbf44Db5105ADF ---------------------------------------------------------------- Erc721 Handler: 0x3f709398808af36ADBA86ACC617FeB7F5B7B193E ---------------------------------------------------------------- Generic Handler: 0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07 ---------------------------------------------------------------- Erc20: 0x21605f71845f372A9ed84253d2D024B7B10999f4 ---------------------------------------------------------------- Erc721: 0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31 ---------------------------------------------------------------- Centrifuge Asset: 0xc279648CE5cAa25B9bA753dAb0Dfef44A069BaF4 ================================================================ Register Resources \u00b6 # Register fungible resource ID with erc20 contract cb-sol-cli bridge register-resource --resourceId \"0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00\" --targetContract \"0x21605f71845f372A9ed84253d2D024B7B10999f4\" # Register non-fungible resource ID with erc721 contract cb-sol-cli bridge register-resource --resourceId \"0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501\" --targetContract \"0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31\" --handler \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" # Register generic resource ID cb-sol-cli bridge register-generic-resource --resourceId \"0x000000000000000000000000000000f44be64d2de895454c3467021928e55e01\" --targetContract \"0xc279648CE5cAa25B9bA753dAb0Dfef44A069BaF4\" --handler \"0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07\" --hash --deposit \"\" --execute \"store(bytes32)\" Specify Token Semantics \u00b6 To allow for a variety of use cases, the Ethereum contracts support both the transfer and the mint/burn ERC methods. For simplicity's sake the following examples only make use of the mint/burn method: # Register the erc20 contract as mintable/burnable cb-sol-cli bridge set-burn --tokenContract \"0x21605f71845f372A9ed84253d2D024B7B10999f4\" # Register the associated handler as a minter cb-sol-cli erc20 add-minter --minter \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" # Register the erc721 contract as mintable/burnable cb-sol-cli bridge set-burn --tokenContract \"0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31\" --handler \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" # Add the handler as a minter cb-sol-cli erc721 add-minter --minter \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" On-Chain Setup (Substrate) \u00b6 Registering Relayers \u00b6 First we need to register the account of the relayer on substrate (cb-sol-cli deploys contracts with the 5 test keys preloaded). Select the Sudo tab in the PolkadotJS UI. Choose the addRelayer method of chainBridge , and select Alice as the relayer. Register Resources \u00b6 Select the Sudo tab and call chainBridge.setResourceId for each of the transfer types you wish to use: Fungible (Native asset): Id: 0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00 Method: 0x4578616d706c652e7472616e73666572 (utf-8 encoding of \"Example.transfer\") NonFungible(ERC721): Id: 0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501 Method: 0x4578616d706c652e6d696e745f657263373231 (utf-8 encoding of \"Example.mint_erc721\") Generic (Hash Transfer): Id: 0x000000000000000000000000000000f44be64d2de895454c3467021928e55e01 Method: 0x4578616d706c652e72656d61726b (utf-8 encoding of \"Example.remark\") Whitelist Chains \u00b6 Using the Sudo tab, call chainBridge.whitelistChain , specifying 0 for out ethereum chain ID. Running A Relayer \u00b6 Here is an example config file for a single relayer (\"Alice\") using the contracts we've deployed. { \"chains\" : [ { \"name\" : \"eth\" , \"type\" : \"ethereum\" , \"id\" : \"0\" , \"endpoint\" : \"ws://localhost:8545\" , \"from\" : \"0xff93B45308FD417dF303D6515aB04D9e89a750Ca\" , \"opts\" : { \"bridge\" : \"0x62877dDCd49aD22f5eDfc6ac108e9a4b5D2bD88B\" , \"erc20Handler\" : \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" , \"erc721Handler\" : \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" , \"genericHandler\" : \"0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07\" , \"gasLimit\" : \"1000000\" , \"maxGasPrice\" : \"20000000\" } }, { \"name\" : \"sub\" , \"type\" : \"substrate\" , \"id\" : \"1\" , \"endpoint\" : \"ws://localhost:9944\" , \"from\" : \"5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\" , \"opts\" : {} } ] } Run make install in ChanBridge directory to build chainbridge and put it in GOBIN path, You can then start a relayer as a binary using the default \"Alice\" key. chainbridge --config config.json --testkey alice --latest OR By building an image first docker build -t chainsafe/chainbridge . You can start the relayer as a docker container docker run -v ./config.json:/config.json --network host chainsafe/chainbridge --testkey alice --latest Fungible Transfers \u00b6 Substrate Native Token \u21d2 ERC 20 \u00b6 In the substrate UI select the Extrinsics tab, and call example.transferNative with these parameters: Amount: 1000 (select Pico for units) Recipient: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca Dest Id: 0 You can query the recipients balance on ethereum with this: cb-sol-cli erc20 balance --address \"0xff93B45308FD417dF303D6515aB04D9e89a750Ca\" ERC20 \u21d2 Substrate Native Token \u00b6 If necessary, you can mint some tokens: cb-sol-cli erc20 mint --amount 1000 Before initiating the transfer we have to approve the bridge to take ownership of the tokens: cb-sol-cli erc20 approve --amount 1000 --recipient \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" To initiate a transfer on the ethereum chain use this command (Note: there will be a 10 block delay before the relayer will process the transfer): cb-sol-cli erc20 deposit --amount 1 --dest 1 --recipient \"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d\" --resourceId \"0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00\" Non-Fungible Transfers \u00b6 Substrate NFT \u21d2 ERC721 \u00b6 First, you'll need to mint a token. Select the Sudo tab and call erc721.mint with parameters such as these: Owner: Alice TokenId: 1 Metadata: \"\" Now the owner of the token can initiate a transfer by calling example.transferErc721 : Recipient: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca TokenId: 1 DestId: 0 You can query ownership of tokens on ethereum with this: cb-sol-cli erc721 owner --id 0x1 ERC721 \u21d2 Substrate NFT \u00b6 If necessary, you can mint an erc721 token like this: cb-sol-cli erc721 mint --id 0x99 Before initiating the transfer, we must approve the bridge to take ownership of the tokens: cb-sol-cli erc721 approve --id 0x99 --recipient \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" Now we can initiate the transfer: cb-sol-cli erc721 deposit --id 0x99 --dest 1 --resourceId \"0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501\" --recipient \"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d\" Generic Data Transfer \u00b6 To demonstrate a possible use of the generic data transfer, we have a hash registry on ethereum. We also have a method on the example substrate chain to emit a hash inside an event, which we can trigger from ethereum. Generic Data Substrate \u21d2 Eth \u00b6 For this example we will transfer a 32 byte hash to a registry on ethereum. Using the Extrinsics tab, call example.transferHash : Hash: 0x699c776c7e6ce8e6d96d979b60e41135a13a2303ae1610c8d546f31f0c6dc730 Dest ID: 0 You can verify the transfer with this command: cb-sol-cli cent getHash --hash 0x699c776c7e6ce8e6d96d979b60e41135a13a2303ae1610c8d546f31f0c6dc730","title":"Running Locally"},{"location":"local/#running-locally","text":"","title":"Running Locally"},{"location":"local/#prerequisites","text":"Docker, docker-compose chainbridge v1.0.0 binary (see README ) Polkadot JS Portal ( https://portal.chain.centrifuge.io ) Connect to your local node (below) by clicking in the top-left corner and using ws://localhost:9944 You will need to setup the type definitions for the chain by selecting Settings -> Developer Type definitions can be found here: PolkadotJS Apps cb-sol-cli (see README )","title":"Prerequisites"},{"location":"local/#starting-local-chains","text":"The easiest way to get started is to use the docker-compose file found here: https://gist.github.com/ansermino/f1571bb354d2007b26dce53d52dbca75 . This will start a geth instance and an instance of chainbridge-substrate-chain: docker-compose -f ./docker-compose-geth-substrate.yml up -V (Use -V to always start with new chains. These instructions depend on deterministic ethereum addresses, which are used as defaults implicitly by some of these commands. Avoid re-deploying the contracts without restarting both chains, or ensure to specify all the required parameters.)","title":"Starting Local Chains"},{"location":"local/#on-chain-setup-ethereum","text":"","title":"On-Chain Setup (Ethereum)"},{"location":"local/#deploy-contracts","text":"To deploy the contracts on to the Ethereum chain, run the following: cb-sol-cli deploy --all --relayerThreshold 1 After running, the expected output looks like this: ================================================================ Url: http://localhost:8545 Deployer: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca Gas Limit: 8000000 Gas Price: 20000000 Deploy Cost: 0 .0 Options ======= Chain Id: 0 Threshold: 2 Relayers: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca,0x8e0a907331554AF72563Bd8D43051C2E64Be5d35,0x24962717f8fA5BA3b931bACaF9ac03924EB475a0,0x148FfB2074A9e59eD58142822b3eB3fcBffb0cd7,0x4CEEf6139f00F9F4535Ad19640Ff7A0137708485 Bridge Fee: 0 Expiry: 100 Contract Addresses ================================================================ Bridge: 0x62877dDCd49aD22f5eDfc6ac108e9a4b5D2bD88B ---------------------------------------------------------------- Erc20 Handler: 0x3167776db165D8eA0f51790CA2bbf44Db5105ADF ---------------------------------------------------------------- Erc721 Handler: 0x3f709398808af36ADBA86ACC617FeB7F5B7B193E ---------------------------------------------------------------- Generic Handler: 0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07 ---------------------------------------------------------------- Erc20: 0x21605f71845f372A9ed84253d2D024B7B10999f4 ---------------------------------------------------------------- Erc721: 0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31 ---------------------------------------------------------------- Centrifuge Asset: 0xc279648CE5cAa25B9bA753dAb0Dfef44A069BaF4 ================================================================","title":"Deploy Contracts"},{"location":"local/#register-resources","text":"# Register fungible resource ID with erc20 contract cb-sol-cli bridge register-resource --resourceId \"0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00\" --targetContract \"0x21605f71845f372A9ed84253d2D024B7B10999f4\" # Register non-fungible resource ID with erc721 contract cb-sol-cli bridge register-resource --resourceId \"0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501\" --targetContract \"0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31\" --handler \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" # Register generic resource ID cb-sol-cli bridge register-generic-resource --resourceId \"0x000000000000000000000000000000f44be64d2de895454c3467021928e55e01\" --targetContract \"0xc279648CE5cAa25B9bA753dAb0Dfef44A069BaF4\" --handler \"0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07\" --hash --deposit \"\" --execute \"store(bytes32)\"","title":"Register Resources"},{"location":"local/#specify-token-semantics","text":"To allow for a variety of use cases, the Ethereum contracts support both the transfer and the mint/burn ERC methods. For simplicity's sake the following examples only make use of the mint/burn method: # Register the erc20 contract as mintable/burnable cb-sol-cli bridge set-burn --tokenContract \"0x21605f71845f372A9ed84253d2D024B7B10999f4\" # Register the associated handler as a minter cb-sol-cli erc20 add-minter --minter \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" # Register the erc721 contract as mintable/burnable cb-sol-cli bridge set-burn --tokenContract \"0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31\" --handler \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" # Add the handler as a minter cb-sol-cli erc721 add-minter --minter \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\"","title":"Specify Token Semantics"},{"location":"local/#on-chain-setup-substrate","text":"","title":"On-Chain Setup (Substrate)"},{"location":"local/#registering-relayers","text":"First we need to register the account of the relayer on substrate (cb-sol-cli deploys contracts with the 5 test keys preloaded). Select the Sudo tab in the PolkadotJS UI. Choose the addRelayer method of chainBridge , and select Alice as the relayer.","title":"Registering Relayers"},{"location":"local/#register-resources_1","text":"Select the Sudo tab and call chainBridge.setResourceId for each of the transfer types you wish to use: Fungible (Native asset): Id: 0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00 Method: 0x4578616d706c652e7472616e73666572 (utf-8 encoding of \"Example.transfer\") NonFungible(ERC721): Id: 0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501 Method: 0x4578616d706c652e6d696e745f657263373231 (utf-8 encoding of \"Example.mint_erc721\") Generic (Hash Transfer): Id: 0x000000000000000000000000000000f44be64d2de895454c3467021928e55e01 Method: 0x4578616d706c652e72656d61726b (utf-8 encoding of \"Example.remark\")","title":"Register Resources"},{"location":"local/#whitelist-chains","text":"Using the Sudo tab, call chainBridge.whitelistChain , specifying 0 for out ethereum chain ID.","title":"Whitelist Chains"},{"location":"local/#running-a-relayer","text":"Here is an example config file for a single relayer (\"Alice\") using the contracts we've deployed. { \"chains\" : [ { \"name\" : \"eth\" , \"type\" : \"ethereum\" , \"id\" : \"0\" , \"endpoint\" : \"ws://localhost:8545\" , \"from\" : \"0xff93B45308FD417dF303D6515aB04D9e89a750Ca\" , \"opts\" : { \"bridge\" : \"0x62877dDCd49aD22f5eDfc6ac108e9a4b5D2bD88B\" , \"erc20Handler\" : \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" , \"erc721Handler\" : \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" , \"genericHandler\" : \"0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07\" , \"gasLimit\" : \"1000000\" , \"maxGasPrice\" : \"20000000\" } }, { \"name\" : \"sub\" , \"type\" : \"substrate\" , \"id\" : \"1\" , \"endpoint\" : \"ws://localhost:9944\" , \"from\" : \"5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\" , \"opts\" : {} } ] } Run make install in ChanBridge directory to build chainbridge and put it in GOBIN path, You can then start a relayer as a binary using the default \"Alice\" key. chainbridge --config config.json --testkey alice --latest OR By building an image first docker build -t chainsafe/chainbridge . You can start the relayer as a docker container docker run -v ./config.json:/config.json --network host chainsafe/chainbridge --testkey alice --latest","title":"Running A Relayer"},{"location":"local/#fungible-transfers","text":"","title":"Fungible Transfers"},{"location":"local/#substrate-native-token-erc-20","text":"In the substrate UI select the Extrinsics tab, and call example.transferNative with these parameters: Amount: 1000 (select Pico for units) Recipient: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca Dest Id: 0 You can query the recipients balance on ethereum with this: cb-sol-cli erc20 balance --address \"0xff93B45308FD417dF303D6515aB04D9e89a750Ca\"","title":"Substrate Native Token \u21d2 ERC 20"},{"location":"local/#erc20-substrate-native-token","text":"If necessary, you can mint some tokens: cb-sol-cli erc20 mint --amount 1000 Before initiating the transfer we have to approve the bridge to take ownership of the tokens: cb-sol-cli erc20 approve --amount 1000 --recipient \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" To initiate a transfer on the ethereum chain use this command (Note: there will be a 10 block delay before the relayer will process the transfer): cb-sol-cli erc20 deposit --amount 1 --dest 1 --recipient \"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d\" --resourceId \"0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00\"","title":"ERC20 \u21d2 Substrate Native Token"},{"location":"local/#non-fungible-transfers","text":"","title":"Non-Fungible Transfers"},{"location":"local/#substrate-nft-erc721","text":"First, you'll need to mint a token. Select the Sudo tab and call erc721.mint with parameters such as these: Owner: Alice TokenId: 1 Metadata: \"\" Now the owner of the token can initiate a transfer by calling example.transferErc721 : Recipient: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca TokenId: 1 DestId: 0 You can query ownership of tokens on ethereum with this: cb-sol-cli erc721 owner --id 0x1","title":"Substrate NFT \u21d2 ERC721"},{"location":"local/#erc721-substrate-nft","text":"If necessary, you can mint an erc721 token like this: cb-sol-cli erc721 mint --id 0x99 Before initiating the transfer, we must approve the bridge to take ownership of the tokens: cb-sol-cli erc721 approve --id 0x99 --recipient \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" Now we can initiate the transfer: cb-sol-cli erc721 deposit --id 0x99 --dest 1 --resourceId \"0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501\" --recipient \"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d\"","title":"ERC721 \u21d2 Substrate NFT"},{"location":"local/#generic-data-transfer","text":"To demonstrate a possible use of the generic data transfer, we have a hash registry on ethereum. We also have a method on the example substrate chain to emit a hash inside an event, which we can trigger from ethereum.","title":"Generic Data Transfer"},{"location":"local/#generic-data-substrate-eth","text":"For this example we will transfer a 32 byte hash to a registry on ethereum. Using the Extrinsics tab, call example.transferHash : Hash: 0x699c776c7e6ce8e6d96d979b60e41135a13a2303ae1610c8d546f31f0c6dc730 Dest ID: 0 You can verify the transfer with this command: cb-sol-cli cent getHash --hash 0x699c776c7e6ce8e6d96d979b60e41135a13a2303ae1610c8d546f31f0c6dc730","title":"Generic Data Substrate \u21d2 Eth"},{"location":"metrics/","text":"Metrics \u00b6 Basic metrics and a health status check can be enabled with the --metrics flag (default port 8001 , use --metricsPort to specify). Prometheus \u00b6 Prometheus metrics are served on /metrics . For each chain that exists, this provides: - <chain>_blocks_processed : the number of blocks processed by the chains listener. - <chain>_latest_processed_block : most recent block that has been processed by the listener. - <chain>_latest_known_block : most recent block that exists on the chain. - <chain>_votes_submitted : number of votes submitted by the relayer. Health Check \u00b6 The endpoint /health will return the current known block height, and a timestamp of when it was first seen for every chain: ```json { \"chains\": [ { \"chainId\": \"Number\", \"height\": \"Number\", \"lastUpdated\": \"Date\" } ] } If the timestamp is at least 120 seconds old an error will be returned instead: ```json { \"error\": \"String\" }","title":"Metrics"},{"location":"metrics/#metrics","text":"Basic metrics and a health status check can be enabled with the --metrics flag (default port 8001 , use --metricsPort to specify).","title":"Metrics"},{"location":"metrics/#prometheus","text":"Prometheus metrics are served on /metrics . For each chain that exists, this provides: - <chain>_blocks_processed : the number of blocks processed by the chains listener. - <chain>_latest_processed_block : most recent block that has been processed by the listener. - <chain>_latest_known_block : most recent block that exists on the chain. - <chain>_votes_submitted : number of votes submitted by the relayer.","title":"Prometheus"},{"location":"metrics/#health-check","text":"The endpoint /health will return the current known block height, and a timestamp of when it was first seen for every chain: ```json { \"chains\": [ { \"chainId\": \"Number\", \"height\": \"Number\", \"lastUpdated\": \"Date\" } ] } If the timestamp is at least 120 seconds old an error will be returned instead: ```json { \"error\": \"String\" }","title":"Health Check"},{"location":"spec/","text":"ChainBridge Specification \u00b6 Summary \u00b6 ChainBridge is a modular multi-directional blockchain bridge to allow data and value transfer between any number of blockchains. This should enable users to specify a destination blockchain from their source chain, and send data to that blockchain for consumption on the destination chain. This could be a token that is locked on ChainA and redeemed on ChainB, or an operation that is executed on a destination chain and initiated on the source chain. The bridge should maintain a set of relayers that are authorized to make & process transfers across the different blockchains. The bridge design should be modular enough that the addition of a new type of transfer should not require a full re-deployment of the suite of tools, rather small modular upgrades. Definitions \u00b6 Chain ID \u00b6 Each chain has a unique 8-bit identifier. We presently define the following chain IDs (subject to change): ID Chain 0 ETH Mainnet 1 ETC Mainnet 2 Centrifuge Network 3 Aragon Chain .. .. Deposit Nonce \u00b6 A nonce must be generated for every transfer to ensure uniqueness. All implementations must track a sequential nonce (unsigned 64-bit integer) for each possible destination chain. This is included as a standard parameter for each transfer. Order is not enforced. Resource ID \u00b6 In order to provide generality, we need some way to associate some action on a source chain to some action on a destination chain. This may express tokenX on chain A is equivalent to tokenY on chain B, or to simply associate that some action performed on chain A should result in some other action occurring on chain B. All resource IDs are considered to have a Home Chain. The only strict requirements for Resource IDs is that they must be 32 bytes in length and the least significant byte must contain a chain ID. Transfer Flow \u00b6 User initiates a transfer on the source chain. Relayers observing the chain parse the parameters of the transfer and format them into a message. The message is parsed and then proposed on the destination chain. If the vote threshold is met, the proposal will be executed to finalize the transfer. After the initiation, a user should not be required to make any additional interactions. Transfer Types \u00b6 In a effort to balance the goals of allowing simple integration and proving generalized transfers, multiple transfer types are defined. Some or all of these may implemented for a chain. Event Description FungibleTransfer Transfer of fungible assets NonFungibleTransfer Transfer of non-fungible assets GenericTransfer Transfer of arbitrary data All transfers contain a source chain, destination chain, deposit nonce, resource ID and transfer-specific parameters. Fungible \u00b6 Field Type Description Amount 256 bit uint The total number of assets being transferred Recipient 32 bytes The recipient address on the destination chain Non-Fungible \u00b6 Field Type Description Token ID 256 bit uint The unique identifier for the NFT Recipient 32 bytes The recipient address on the destination chain Metadata variable sized bytes Any additional data associated to the NFT Generic \u00b6 Field Type Description Metadata variable sized bytes An opaque payload to transmit Note: Addresses are limited to 32bytes in size, but may be smaller. They must always be compatible with the destination chain. Relayer Set \u00b6 Each chain implementation must track a set of relayers, and allow updating of the set as necessary. A threshold should also be maintained to define how many relayers must vote for a proposed transfer before is can be executed. For this initial implementation, the relayer set may be controlled by a single party. Multi-signature wallets can be used to distribute risk, if available on the chain. Implementation \u00b6 This sections defines the specifics of the ChainBridge implementation and the requirements for a chain integration. Components \u00b6 Chain \u00b6 A chain is loosely defined as consisting of three major components: Connection : A container for on chain interactions. Shared by the listener and writer. Listener : Observes chain state transitions to watch for initiated transfers. When a transfer is encountered it should construct a message and pass it to the router. Writer : Responsible for performing on-chain actions. This will parse a proposed transfer from a message and enact it on-chain. These vary considerably depending on the chain. As long as the on-chain components are compatible, following the internal message protocol should be sufficient to be compatible with the system. These components are intended for architectural guidance and are only loosely constrained. Message \u00b6 A message represents a single transfer and its associated parameters. type Message struct { Source ChainId Destination ChainId Type TransferType DepositNonce Nonce ResourceId ResourceId Payload [] interface {} } The payload field contains the data for the specific transfer, as defined above . Router \u00b6 The router is responsible for taking messages from a source chain and routing them to their destination chain. The router provides an interface to allow Listeners to submit constructed messages: type Router interface { Send ( message msg . Message ) error } All chains must fulfill a Writer interface to receive messages from the router: type Writer interface { ResolveMessage ( message msg . Message ) bool }","title":"ChainBridge"},{"location":"spec/#chainbridge-specification","text":"","title":"ChainBridge Specification"},{"location":"spec/#summary","text":"ChainBridge is a modular multi-directional blockchain bridge to allow data and value transfer between any number of blockchains. This should enable users to specify a destination blockchain from their source chain, and send data to that blockchain for consumption on the destination chain. This could be a token that is locked on ChainA and redeemed on ChainB, or an operation that is executed on a destination chain and initiated on the source chain. The bridge should maintain a set of relayers that are authorized to make & process transfers across the different blockchains. The bridge design should be modular enough that the addition of a new type of transfer should not require a full re-deployment of the suite of tools, rather small modular upgrades.","title":"Summary"},{"location":"spec/#definitions","text":"","title":"Definitions"},{"location":"spec/#chain-id","text":"Each chain has a unique 8-bit identifier. We presently define the following chain IDs (subject to change): ID Chain 0 ETH Mainnet 1 ETC Mainnet 2 Centrifuge Network 3 Aragon Chain .. ..","title":"Chain ID"},{"location":"spec/#deposit-nonce","text":"A nonce must be generated for every transfer to ensure uniqueness. All implementations must track a sequential nonce (unsigned 64-bit integer) for each possible destination chain. This is included as a standard parameter for each transfer. Order is not enforced.","title":"Deposit Nonce"},{"location":"spec/#resource-id","text":"In order to provide generality, we need some way to associate some action on a source chain to some action on a destination chain. This may express tokenX on chain A is equivalent to tokenY on chain B, or to simply associate that some action performed on chain A should result in some other action occurring on chain B. All resource IDs are considered to have a Home Chain. The only strict requirements for Resource IDs is that they must be 32 bytes in length and the least significant byte must contain a chain ID.","title":"Resource ID"},{"location":"spec/#transfer-flow","text":"User initiates a transfer on the source chain. Relayers observing the chain parse the parameters of the transfer and format them into a message. The message is parsed and then proposed on the destination chain. If the vote threshold is met, the proposal will be executed to finalize the transfer. After the initiation, a user should not be required to make any additional interactions.","title":"Transfer Flow"},{"location":"spec/#transfer-types","text":"In a effort to balance the goals of allowing simple integration and proving generalized transfers, multiple transfer types are defined. Some or all of these may implemented for a chain. Event Description FungibleTransfer Transfer of fungible assets NonFungibleTransfer Transfer of non-fungible assets GenericTransfer Transfer of arbitrary data All transfers contain a source chain, destination chain, deposit nonce, resource ID and transfer-specific parameters.","title":"Transfer Types"},{"location":"spec/#fungible","text":"Field Type Description Amount 256 bit uint The total number of assets being transferred Recipient 32 bytes The recipient address on the destination chain","title":"Fungible"},{"location":"spec/#non-fungible","text":"Field Type Description Token ID 256 bit uint The unique identifier for the NFT Recipient 32 bytes The recipient address on the destination chain Metadata variable sized bytes Any additional data associated to the NFT","title":"Non-Fungible"},{"location":"spec/#generic","text":"Field Type Description Metadata variable sized bytes An opaque payload to transmit Note: Addresses are limited to 32bytes in size, but may be smaller. They must always be compatible with the destination chain.","title":"Generic"},{"location":"spec/#relayer-set","text":"Each chain implementation must track a set of relayers, and allow updating of the set as necessary. A threshold should also be maintained to define how many relayers must vote for a proposed transfer before is can be executed. For this initial implementation, the relayer set may be controlled by a single party. Multi-signature wallets can be used to distribute risk, if available on the chain.","title":"Relayer Set"},{"location":"spec/#implementation","text":"This sections defines the specifics of the ChainBridge implementation and the requirements for a chain integration.","title":"Implementation"},{"location":"spec/#components","text":"","title":"Components"},{"location":"spec/#chain","text":"A chain is loosely defined as consisting of three major components: Connection : A container for on chain interactions. Shared by the listener and writer. Listener : Observes chain state transitions to watch for initiated transfers. When a transfer is encountered it should construct a message and pass it to the router. Writer : Responsible for performing on-chain actions. This will parse a proposed transfer from a message and enact it on-chain. These vary considerably depending on the chain. As long as the on-chain components are compatible, following the internal message protocol should be sufficient to be compatible with the system. These components are intended for architectural guidance and are only loosely constrained.","title":"Chain"},{"location":"spec/#message","text":"A message represents a single transfer and its associated parameters. type Message struct { Source ChainId Destination ChainId Type TransferType DepositNonce Nonce ResourceId ResourceId Payload [] interface {} } The payload field contains the data for the specific transfer, as defined above .","title":"Message"},{"location":"spec/#router","text":"The router is responsible for taking messages from a source chain and routing them to their destination chain. The router provides an interface to allow Listeners to submit constructed messages: type Router interface { Send ( message msg . Message ) error } All chains must fulfill a Writer interface to receive messages from the router: type Writer interface { ResolveMessage ( message msg . Message ) bool }","title":"Router"},{"location":"test/","text":"Testing \u00b6 Unit tests require an ethereum node running on localhost:8545 and a substrate node running on localhost:9944 . E2E tests require an additional ethereum node on localhost:8546 . A docker-compose file is provided to run two Geth nodes and a chainbridge-substrate-chain node in isolated environments: $ docker-compose -f ./docker-compose-e2e.yml up See chainbridge-solidity and chainbridge-substrate-chain for more information on testing facilities. All Go tests can be run with: $ make test Go tests specifically for ethereum, substrate and E2E can be run with $ make test-eth $ make test-sub $ make test-e2e The bindings for the solidity contracts live in bindings/ . To update the bindings modify scripts/setup-contracts.sh and then run make clean && make setup-contracts","title":"Testing"},{"location":"test/#testing","text":"Unit tests require an ethereum node running on localhost:8545 and a substrate node running on localhost:9944 . E2E tests require an additional ethereum node on localhost:8546 . A docker-compose file is provided to run two Geth nodes and a chainbridge-substrate-chain node in isolated environments: $ docker-compose -f ./docker-compose-e2e.yml up See chainbridge-solidity and chainbridge-substrate-chain for more information on testing facilities. All Go tests can be run with: $ make test Go tests specifically for ethereum, substrate and E2E can be run with $ make test-eth $ make test-sub $ make test-e2e The bindings for the solidity contracts live in bindings/ . To update the bindings modify scripts/setup-contracts.sh and then run make clean && make setup-contracts","title":"Testing"},{"location":"chains/ethereum/","text":"Ethereum Implementation Specification \u00b6 The solidity implementation of ChainBridge should consist of a central Bridge contract, and will delegate specific functionality to handlers . Fungible and non-fungible compatibility should be focused on ERC20 and ERC721 tokens. Transfer Flow \u00b6 As Source Chain \u00b6 Some user calls the deposit function on the bridge contract. A depositRecord is created on the bridge and a call is delgated to a handler contract specified by the provided resourceID . The specified handler's deposit function validates the parameters provided by the user. If successful, a depositRecord is created on the handler. If the call delegated to the handler is succesful, the bridge emits a Deposit event. Relayers parse the Deposit event and retrieve the associated DepositRecord from the handler to construct a message. As Destination Chain \u00b6 A Relayer calls voteProposal on the bridge contract. If a proposal corresponding with the parameters passed in does not exist, it is created and the Relayer's vote is recorded. If the proposal already exists, the Relayer's vote is simply recorded. Once we have met some vote threshold for a proposal , the bridge emits a ProposalFinalized event. Upon seeing a ProposalFinalized event, Relayers call the executeDeposit function on the bridge. executeDeposit delegates a call to a handler contract specified by the associated resourceID . The specified handler's executeDeposit function validates the paramters provided and makes a call to some contract to complete the transfer. Bridge Contract \u00b6 Users and relayers will interact with the Bridge contract. This delegates calls to the handler contracts for deposits and executing proposals. function deposit ( uint8 destinationChainID, bytes32 resourceID, bytes calldata data ) Handler Contracts \u00b6 To provide modularity and break out the necessary contract logic, the implementation uses a notion of handlers. A handler is defined for ERC20, ERC721 and generic transfers. These map directly to the Fungible, Non-Fungible, and generic transfer types. A handler must fulfill two interfaces: // Will be called by the bridge contract to initiate a transfer function deposit(uint8 destinationChainID, uint64 depositNonce, address depositer, bytes calldata data) // TODO: This would be more aptly named executeProposal // Called by the bridge contract to complete a transfer function executeDeposit(bytes calldata data) The calldata field is the parameters required for the handler. The exact serialization is defined for each handler. ERC20 & ERC721 Handlers \u00b6 These handlers share a lot of similarities. These handlers are responsible for transferring ERC assets. They should provide the ability for the bridge to take ownership of tokens and release tokens to execute transfers. Different configurations may require different interface interactions. For example, it may make sense to mint and burn a token that is originally from another chain. If supply needs to be controlled, transferring tokens in and out of a reserve may be desired instead. To support either case handlers should associate each resource ID/token contract with one of these: transferFrom() - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call transferFrom() as part of the transfer initiation. For the inverse, the handler will call transfer() to release tokens from the handlers ownership. mint() / burn() - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call burnFrom() as part of the transfer initiation. For the inverse, the handler will call mint() to release tokens to the recipient (and must have privileges to do so). ERC20 Handler \u00b6 Calldata for deposit() \u00b6 Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END Calldata for executeDeposit() \u00b6 Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - END ERC721 Handler \u00b6 Metadata \u00b6 The tokenURI should be used as the metadata field if the contract supports the Metadata extension (interface ID 0x5b5e139f ). Calldata for deposit() \u00b6 Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END Calldata for executeDeposit() \u00b6 Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - 95 Metadata Length uint256 96 - 127 Metadata bytes 128 - END Generic Handler \u00b6 As well as associating a resource ID to a contract address, the generic handler should allow specific functions on those contracts to be used. To allow for this we must: Use function selectors to identify functions. Require functions that accept bytes as a the only parameter OR require the data already be ABI encoded for the function Deposit \u00b6 In a generic context, a deposit is simply the initiation of a transfer of a piece of data. To (optionally) allow this data to be validated for transfer the deposit mechanism should pass the data to a specified function and proceed with the transfer if the call succeeds (ie. does not revert). A function selector of 0x00 should skip the deposit function call. Execute \u00b6 An execution function must be specified. When executeDeposit() is called on the handler it should pass the metadata field to the specified function. Calldata for deposit() \u00b6 Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END Calldata for execute() \u00b6 Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END Administration \u00b6 The contracts should be controlled by an admin account. This should control the relayer set, manage the resource IDs, and specify the handlers. It should also be able to pause and unpause transfers at any times.","title":"Ethereum"},{"location":"chains/ethereum/#ethereum-implementation-specification","text":"The solidity implementation of ChainBridge should consist of a central Bridge contract, and will delegate specific functionality to handlers . Fungible and non-fungible compatibility should be focused on ERC20 and ERC721 tokens.","title":"Ethereum Implementation Specification"},{"location":"chains/ethereum/#transfer-flow","text":"","title":"Transfer Flow"},{"location":"chains/ethereum/#as-source-chain","text":"Some user calls the deposit function on the bridge contract. A depositRecord is created on the bridge and a call is delgated to a handler contract specified by the provided resourceID . The specified handler's deposit function validates the parameters provided by the user. If successful, a depositRecord is created on the handler. If the call delegated to the handler is succesful, the bridge emits a Deposit event. Relayers parse the Deposit event and retrieve the associated DepositRecord from the handler to construct a message.","title":"As Source Chain"},{"location":"chains/ethereum/#as-destination-chain","text":"A Relayer calls voteProposal on the bridge contract. If a proposal corresponding with the parameters passed in does not exist, it is created and the Relayer's vote is recorded. If the proposal already exists, the Relayer's vote is simply recorded. Once we have met some vote threshold for a proposal , the bridge emits a ProposalFinalized event. Upon seeing a ProposalFinalized event, Relayers call the executeDeposit function on the bridge. executeDeposit delegates a call to a handler contract specified by the associated resourceID . The specified handler's executeDeposit function validates the paramters provided and makes a call to some contract to complete the transfer.","title":"As Destination Chain"},{"location":"chains/ethereum/#bridge-contract","text":"Users and relayers will interact with the Bridge contract. This delegates calls to the handler contracts for deposits and executing proposals. function deposit ( uint8 destinationChainID, bytes32 resourceID, bytes calldata data )","title":"Bridge Contract"},{"location":"chains/ethereum/#handler-contracts","text":"To provide modularity and break out the necessary contract logic, the implementation uses a notion of handlers. A handler is defined for ERC20, ERC721 and generic transfers. These map directly to the Fungible, Non-Fungible, and generic transfer types. A handler must fulfill two interfaces: // Will be called by the bridge contract to initiate a transfer function deposit(uint8 destinationChainID, uint64 depositNonce, address depositer, bytes calldata data) // TODO: This would be more aptly named executeProposal // Called by the bridge contract to complete a transfer function executeDeposit(bytes calldata data) The calldata field is the parameters required for the handler. The exact serialization is defined for each handler.","title":"Handler Contracts"},{"location":"chains/ethereum/#erc20-erc721-handlers","text":"These handlers share a lot of similarities. These handlers are responsible for transferring ERC assets. They should provide the ability for the bridge to take ownership of tokens and release tokens to execute transfers. Different configurations may require different interface interactions. For example, it may make sense to mint and burn a token that is originally from another chain. If supply needs to be controlled, transferring tokens in and out of a reserve may be desired instead. To support either case handlers should associate each resource ID/token contract with one of these: transferFrom() - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call transferFrom() as part of the transfer initiation. For the inverse, the handler will call transfer() to release tokens from the handlers ownership. mint() / burn() - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call burnFrom() as part of the transfer initiation. For the inverse, the handler will call mint() to release tokens to the recipient (and must have privileges to do so).","title":"ERC20 &amp; ERC721 Handlers"},{"location":"chains/ethereum/#erc20-handler","text":"","title":"ERC20 Handler"},{"location":"chains/ethereum/#calldata-for-deposit","text":"Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END","title":"Calldata for deposit()"},{"location":"chains/ethereum/#calldata-for-executedeposit","text":"Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - END","title":"Calldata for executeDeposit()"},{"location":"chains/ethereum/#erc721-handler","text":"","title":"ERC721 Handler"},{"location":"chains/ethereum/#metadata","text":"The tokenURI should be used as the metadata field if the contract supports the Metadata extension (interface ID 0x5b5e139f ).","title":"Metadata"},{"location":"chains/ethereum/#calldata-for-deposit_1","text":"Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END","title":"Calldata for deposit()"},{"location":"chains/ethereum/#calldata-for-executedeposit_1","text":"Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - 95 Metadata Length uint256 96 - 127 Metadata bytes 128 - END","title":"Calldata for executeDeposit()"},{"location":"chains/ethereum/#generic-handler","text":"As well as associating a resource ID to a contract address, the generic handler should allow specific functions on those contracts to be used. To allow for this we must: Use function selectors to identify functions. Require functions that accept bytes as a the only parameter OR require the data already be ABI encoded for the function","title":"Generic Handler"},{"location":"chains/ethereum/#deposit","text":"In a generic context, a deposit is simply the initiation of a transfer of a piece of data. To (optionally) allow this data to be validated for transfer the deposit mechanism should pass the data to a specified function and proceed with the transfer if the call succeeds (ie. does not revert). A function selector of 0x00 should skip the deposit function call.","title":"Deposit"},{"location":"chains/ethereum/#execute","text":"An execution function must be specified. When executeDeposit() is called on the handler it should pass the metadata field to the specified function.","title":"Execute"},{"location":"chains/ethereum/#calldata-for-deposit_2","text":"Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END","title":"Calldata for deposit()"},{"location":"chains/ethereum/#calldata-for-execute","text":"Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END","title":"Calldata for execute()"},{"location":"chains/ethereum/#administration","text":"The contracts should be controlled by an admin account. This should control the relayer set, manage the resource IDs, and specify the handlers. It should also be able to pause and unpause transfers at any times.","title":"Administration"},{"location":"chains/substrate/","text":"Substrate Implementation Specification \u00b6 The ChainBridge Substrate implementation will consist of a Substrate pallet that can be integrated into a runtime to enable bridging of additional pallet functionality. Due to the complexities of the Substrate API we must define some limitations to the supported calls, however the pallet should define a Proposal type equivalent to a dispatchable call to theoretically allow for any call to be made. pub trait Trait : system :: Trait { type Proposal : Parameter + Dispatchable < Origin = Self :: Origin > + EncodeLike + GetDispatchInfo ; } Events \u00b6 To easily distinguish different transfer types we should define three event types: /// FungibleTransfer is for relaying fungibles (dest_id, nonce, resource_id, amount, recipient, metadata) FungibleTransfer ( ChainId , DepositNonce , ResourceId , U256 , Vec < u8 > ) /// NonFungibleTransfer is for relaying NFTS (dest_id, nonce, resource_id, token_id, recipient, metadata) NonFungibleTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > , Vec < u8 > , Vec < u8 > ) /// GenericTransfer is for a generic data payload (dest_id, nonce, resource_id, metadata) GenericTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > ) These can be observed by relayers and should provide enough context to construct transfer messages. Inter-Pallet Communication \u00b6 The ChainBridge pallet is intended to be combined with other pallets to define what is being bridged. To allow for this we must define some methods that other pallets can call to initiate transfers: pub fn transfer_fungible ( dest_id : ChainId , resource_id : ResourceId , to : Vec < u8 > , amount : U256 ,) pub fn transfer_nonfungible ( dest_id : ChainId , resource_id : ResourceId , token_id : Vec < u8 > , to : Vec < u8 > , metadata : Vec < u8 > ) pub fn transfer_generic ( dest_id : ChainId , resource_id : ResourceId , metadata : Vec < u8 > ) These should result in the associated event being emitted with the correct parameters. Bridge Account ID & Origin Check \u00b6 To allow the bridge pallet to take ownership of tokens a ModuleId should be used to derive an AccountId . A bridge origin check (implementing EnsureOrigin ) should also be provided. Other pallets should be able to use this to check the origin of call is the bridge pallet, indicating the execution of a proposal. Executing Calls \u00b6 The pallet should support dispatching of arbitrary calls as the result of successful proposal. Resource IDs should be mapped to specific calls to define their behaviour. Relayers will need to resolve resource IDs to calls in order to submit a proposal. The pallet should provide a mapping of resource IDs to method names that can be updated by the admin. Compatible calls are restrained to the following signature to allow relayers to understand how to construct the calls: - Fungible: Call(origin, recipient: AccountId, amount: u128) - Non-Fungible: Call(origin, recipient: AccountId, tokenId: U256, metadata: Vec<u8>) - Generic: Call(origin, data: Vec<u8>) Note: Calls in substrate are resolved based on a pallet and call index. The pallet index depends on the ordering of pallets in the runtime, and the call index on the ordering of calls in the pallet. As these may change during a runtime upgrade, relayers should use the actual method name string to reference calls","title":"Substrate"},{"location":"chains/substrate/#substrate-implementation-specification","text":"The ChainBridge Substrate implementation will consist of a Substrate pallet that can be integrated into a runtime to enable bridging of additional pallet functionality. Due to the complexities of the Substrate API we must define some limitations to the supported calls, however the pallet should define a Proposal type equivalent to a dispatchable call to theoretically allow for any call to be made. pub trait Trait : system :: Trait { type Proposal : Parameter + Dispatchable < Origin = Self :: Origin > + EncodeLike + GetDispatchInfo ; }","title":"Substrate Implementation Specification"},{"location":"chains/substrate/#events","text":"To easily distinguish different transfer types we should define three event types: /// FungibleTransfer is for relaying fungibles (dest_id, nonce, resource_id, amount, recipient, metadata) FungibleTransfer ( ChainId , DepositNonce , ResourceId , U256 , Vec < u8 > ) /// NonFungibleTransfer is for relaying NFTS (dest_id, nonce, resource_id, token_id, recipient, metadata) NonFungibleTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > , Vec < u8 > , Vec < u8 > ) /// GenericTransfer is for a generic data payload (dest_id, nonce, resource_id, metadata) GenericTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > ) These can be observed by relayers and should provide enough context to construct transfer messages.","title":"Events"},{"location":"chains/substrate/#inter-pallet-communication","text":"The ChainBridge pallet is intended to be combined with other pallets to define what is being bridged. To allow for this we must define some methods that other pallets can call to initiate transfers: pub fn transfer_fungible ( dest_id : ChainId , resource_id : ResourceId , to : Vec < u8 > , amount : U256 ,) pub fn transfer_nonfungible ( dest_id : ChainId , resource_id : ResourceId , token_id : Vec < u8 > , to : Vec < u8 > , metadata : Vec < u8 > ) pub fn transfer_generic ( dest_id : ChainId , resource_id : ResourceId , metadata : Vec < u8 > ) These should result in the associated event being emitted with the correct parameters.","title":"Inter-Pallet Communication"},{"location":"chains/substrate/#bridge-account-id-origin-check","text":"To allow the bridge pallet to take ownership of tokens a ModuleId should be used to derive an AccountId . A bridge origin check (implementing EnsureOrigin ) should also be provided. Other pallets should be able to use this to check the origin of call is the bridge pallet, indicating the execution of a proposal.","title":"Bridge Account ID &amp; Origin Check"},{"location":"chains/substrate/#executing-calls","text":"The pallet should support dispatching of arbitrary calls as the result of successful proposal. Resource IDs should be mapped to specific calls to define their behaviour. Relayers will need to resolve resource IDs to calls in order to submit a proposal. The pallet should provide a mapping of resource IDs to method names that can be updated by the admin. Compatible calls are restrained to the following signature to allow relayers to understand how to construct the calls: - Fungible: Call(origin, recipient: AccountId, amount: u128) - Non-Fungible: Call(origin, recipient: AccountId, tokenId: U256, metadata: Vec<u8>) - Generic: Call(origin, data: Vec<u8>) Note: Calls in substrate are resolved based on a pallet and call index. The pallet index depends on the ordering of pallets in the runtime, and the call index on the ordering of calls in the pallet. As these may change during a runtime upgrade, relayers should use the actual method name string to reference calls","title":"Executing Calls"}]}